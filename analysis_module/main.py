import logging
from .data_fetching import fetch_forex_data
from .data_aggregation import aggregate_data
from .strategy_analysis import analyze_malaysian_strategy
from datetime import datetime, timedelta
import pytz 
import asyncio
from forex.clickhouse.connection import get_clickhouse_client
from trade.views import executeTrade
from .risk_management import calculate_risk

# Configure logging
logging.basicConfig(level=logging.INFO)

# Define the CAT timezone
cat_timezone = pytz.timezone("Africa/Harare")
client = get_clickhouse_client()

async def main():
    """
    Main function to fetch, aggregate, and analyze forex data.

    Args:
        request: The request object (or None during testing).
    
    Returns:
        signals: Trading signals generated by strategy analysis.
    """
    """
        Adding infinite loop to fetch data at every 4hrs
        continuosly
    """
    while True:
        # Get the current time in UTC and align to the start of the current minute
        now_utc = datetime.utcnow()
        aligned_time = now_utc.replace(second=0, microsecond=0)

        # Convert aligned_time to CAT timezone for display
        aligned_time_cat = aligned_time.astimezone(cat_timezone)

        # Fetch data
        df_minute = fetch_forex_data()
        if df_minute is None:
            logging.error("Failed to fetch forex data.")
            return None

        # Aggregate data
        df_4h = aggregate_data(df_minute, "4H")
        df_15m = aggregate_data(df_minute, "15M")

        # Analyze strategy
        signals = analyze_malaysian_strategy(df_4h, df_15m)

        # Output signals
        if signals:
            logging.info("Trading Signals: %s", signals)
        else:
            logging.info("No trading signals generated.")

        if len(signals) > 0:
            save_signals_to_clickhouse(signals)
            await prepare_trading(signals)
        else:
            print("No signal generated")
    
        # Calculate sleep duration
        next_minute = aligned_time + timedelta(minutes=1)
        calculated_sleep_duration = (next_minute - datetime.utcnow()).total_seconds()

        # Minimum sleep duration is 4 hours for production
        # minimum_sleep_duration = 4 * 60 * 60  # 4 hours in seconds
        #15 minutes only fot testing purposes
        minimum_sleep_duration = 15 * 60

        # Ensure the sleep duration is at least 4 hours
        sleep_duration = max(minimum_sleep_duration, calculated_sleep_duration)

        # Display sleep duration and perform the sleep
        if sleep_duration > 0:
            print(f"Sleeping for {sleep_duration} seconds...")
            await asyncio.sleep(sleep_duration)

# invocation
if __name__ == "__main__":
    main()

# sTORING SIGNALS TO CLICKHOUSE
def save_signals_to_clickhouse(signals):
    """
    Save trading signals to a ClickHouse database.

    Args:
        signals (list of dict): A list of signals containing details like Signal, Entry, SL, TP, and Lot Size.
    """
    try:
        table_name = "trading_signals"

        # Define the CAT timezone and get the current timestamp
        cat_timezone = pytz.timezone("Africa/Harare")
        timestamp_cat = datetime.now(tz=cat_timezone)

        # Connect to ClickHouse and create the table if it doesn't exist
        create_table_query = f"""
            CREATE TABLE IF NOT EXISTS {table_name} (
                timestamp DateTime,
                Signal String,
                Entry Float64,
                SL Float64,
                TP Float64,
                Lot_Size Float64
            ) ENGINE = MergeTree()
            ORDER BY timestamp
        """
        client.command(create_table_query)
      
        print("___________________________STARTED STORING SIGNALS________________________________________")
        for s in signals:
            client.command(f"""
                INSERT INTO trading_signals (timestamp, Signal, Entry, SL, TP, Lot_Size) 
                VALUES (NOW(), '{s['Signal']}', {s['Entry']}, {s['SL']}, {s['TP']}, {s['Lot Size']})
                """)
            
            print(f"[{timestamp_cat}] Stored: {s['Signal']}, {s['Entry']}, {s['SL']}, {s['TP']}, {s['Lot Size']}")

        print('___________________________ SIGNALS STORED________________________________________')

    except Exception as e:
        print(f"Error storing signals: {e}")

# Preparing trading 
async def prepare_trading(signals):
    try:
        strategy = "malysian"
        local_symbol = "frxEURUSD"

        if not strategy:
            return("strategy needed")

        # Fetch the token from the database
        result = client.query(f"""
            SELECT token
            FROM userdetails 
            WHERE strategy = '{strategy}' AND trading = true
        """)
        
        if result:
            tokenn  = result.result_set

            """
            For each signal fetch tokens that  choose that strategy
            then using that token also chek those who selected that given symbol
            place trades if choosen symboll and strategy matches what user selected
            fetch balance and calculate  statke amount based on that
            """
            for s in signals:
                for tokens in tokenn:
                    token = tokens[0]

                    symbols = client.query(f"""
                        SELECT symbol
                        FROM symbols
                        WHERE token = '{token}' 
                    """)
                    symbolss = symbols.result_set

                    for sym in symbolss:
                        symbol = sym[0]

                        if  (local_symbol == symbol):
                            # calculate risk analysis and position size
                            position_size = await calculate_risk(s['Entry'], s['SL'],  token)

                            # placing trade iif amount if greater than 1
                            if position_size > 0:
                                print('___________________________ START PLACING TRADES________________________________________')
                                executeTrade(token, position_size, s['TP'], s['SL'], symbol )
                                print('___________________________ TRADE PLACED________________________________________')  
        else:
            return({"error": "Token not found"})

    except Exception as e:
        return({"error": str(e)})
