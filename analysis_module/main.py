import logging
from .data_fetching import fetch_forex_data
from .data_aggregation import aggregate_data
from .strategy_analysis import analyze_malaysian_strategy
from datetime import datetime, timedelta
import pytz 
import asyncio
from forex.clickhouse.connection import get_clickhouse_client

# Configure logging
logging.basicConfig(level=logging.INFO)

# Define the CAT timezone
cat_timezone = pytz.timezone("Africa/Harare")

async def main():
    """
    Main function to fetch, aggregate, and analyze forex data.

    Args:
        request: The request object (or None during testing).
    
    Returns:
        signals: Trading signals generated by strategy analysis.
    """
    """
        Adding infinite loop to fetch data at every 4hrs
        continuosly
    """
    while True:
        # Get the current time in UTC and align to the start of the current minute
        now_utc = datetime.utcnow()
        aligned_time = now_utc.replace(second=0, microsecond=0)

        # Convert aligned_time to CAT timezone for display
        aligned_time_cat = aligned_time.astimezone(cat_timezone)

        # Fetch data
        df_minute = fetch_forex_data()
        if df_minute is None:
            logging.error("Failed to fetch forex data.")
            return None

        # Aggregate data
        df_4h = aggregate_data(df_minute, "4H")
        df_15m = aggregate_data(df_minute, "15M")

        # Analyze strategy
        signals = analyze_malaysian_strategy(df_4h, df_15m)

        # Output signals
        if signals:
            logging.info("Trading Signals: %s", signals)
        else:
            logging.info("No trading signals generated.")

        if len(signals) > 0:
            save_signals_to_clickhouse(signals)
        else:
            print("No signal generated")
    
        # Calculate sleep duration
        next_minute = aligned_time + timedelta(minutes=1)
        calculated_sleep_duration = (next_minute - datetime.utcnow()).total_seconds()

        # Minimum sleep duration is 4 hours for production
        # minimum_sleep_duration = 4 * 60 * 60  # 4 hours in seconds
        #15 minutes only fot testing purposes
        minimum_sleep_duration = 15 * 60

        # Ensure the sleep duration is at least 4 hours
        sleep_duration = max(minimum_sleep_duration, calculated_sleep_duration)

        # Display sleep duration and perform the sleep
        if sleep_duration > 0:
            print(f"Sleeping for {sleep_duration} seconds...")
            await asyncio.sleep(sleep_duration)

# invocation
if __name__ == "__main__":
    main()

# sTORING SIGNALS TO CLICKHOUSE
def save_signals_to_clickhouse(signals):
    """
    Save trading signals to a ClickHouse database.

    Args:
        signals (list of dict): A list of signals containing details like Signal, Entry, SL, TP, and Lot Size.
    """
    try:
        table_name = "trading_signals"

        # Define the CAT timezone and get the current timestamp
        cat_timezone = pytz.timezone("Africa/Harare")
        timestamp_cat = datetime.now(tz=cat_timezone)

        # Connect to ClickHouse and create the table if it doesn't exist
        client = get_clickhouse_client()
        create_table_query = f"""
            CREATE TABLE IF NOT EXISTS {table_name} (
                timestamp DateTime,
                Signal String,
                Entry Float64,
                SL Float64,
                TP Float64,
                Lot_Size Float64
            ) ENGINE = MergeTree()
            ORDER BY timestamp
        """
        client.command(create_table_query)
      
        print("___________________________STARTED STORING SIGNALS________________________________________")
        for s in signals:
            client.command(f"""
                INSERT INTO trading_signals (timestamp, Signal, Entry, SL, TP, Lot_Size) 
                VALUES (NOW(), '{s['Signal']}', {s['Entry']}, {s['SL']}, {s['TP']}, {s['Lot Size']})
                """)
            
            print(f"[{timestamp_cat}] Stored: {s['Signal']}, {s['Entry']}, {s['SL']}, {s['TP']}, {s['Lot Size']}")

        print('___________________________ SIGNALS STORED________________________________________')

    except Exception as e:
        print(f"Error storing signals: {e}")
